<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="description" content="Halit Cengiz Uzuner - Entelektüel ve Mantıkçı">
    <title>Halit Cengiz Uzuner</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Playfair+Display:wght@400;700;900&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body, html {
            width: 100%;
            height: 100%;
            background: #000000;
            overflow: hidden;
            font-family: 'Playfair Display', serif;
            cursor: crosshair;
            -webkit-tap-highlight-color: transparent;
            /* KRİTİK: Tablet için kaydırma engeli */
            touch-action: none;
        }

        #constellation {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
            transition: filter 0.1s ease;
        }

        #constellation.glitch {
            filter: blur(2px) brightness(1.3);
        }

        .content {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 10;
            text-align: center;
            width: 90%;
            max-width: 1200px;
            pointer-events: none;
            transition: transform 2s ease-in-out;
            user-select: none;
        }

        h1 {
            font-size: clamp(2.5rem, 6vw, 5rem);
            font-weight: 900;
            letter-spacing: 0.2em;
            color: #ffffff;
            text-transform: uppercase;
            margin-bottom: 2rem;
            text-shadow: 0 0 40px rgba(255, 255, 255, 0.15);
            line-height: 1.2;
        }

        .subtitle {
            font-size: clamp(0.9rem, 2vw, 1.4rem);
            font-weight: 400;
            letter-spacing: 0.25em;
            color: #aaaaaa;
            text-transform: uppercase;
            margin-bottom: 4rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.15);
            display: inline-block;
            transition: opacity 0.8s ease;
            min-height: 2.5rem;
        }

        .subtitle.fade {
            opacity: 0;
        }

        .countdown {
            display: flex;
            justify-content: center;
            gap: clamp(1.5rem, 4vw, 3rem);
            flex-wrap: wrap;
        }

        .time-unit {
            display: flex;
            flex-direction: column;
            align-items: center;
            min-width: clamp(60px, 10vw, 100px);
        }

        .time-value {
            font-size: clamp(2.5rem, 5vw, 4rem);
            font-weight: 700;
            color: #ffffff;
            line-height: 1;
            font-variant-numeric: tabular-nums;
            text-shadow: 0 0 20px rgba(255, 255, 255, 0.2);
        }

        .time-label {
            font-size: clamp(0.7rem, 1.2vw, 0.9rem);
            font-weight: 400;
            letter-spacing: 0.2em;
            color: #666666;
            margin-top: 0.8rem;
            text-transform: uppercase;
        }

        .aphorism {
            position: absolute;
            font-size: clamp(1rem, 2.5vw, 1.5rem);
            font-weight: 400;
            letter-spacing: 0.15em;
            color: #ffffff;
            text-align: center;
            pointer-events: none;
            z-index: 8;
            text-shadow: 0 0 30px rgba(255, 255, 255, 0.4);
            max-width: 80vw;
            white-space: nowrap;
            animation: aphorism-fade 2.5s ease-in-out forwards;
        }

        @keyframes aphorism-fade {
            0% { opacity: 0; transform: translateY(10px) translate(-50%, -50%); }
            20% { opacity: 1; transform: translateY(0) translate(-50%, -50%); }
            80% { opacity: 1; transform: translateY(0) translate(-50%, -50%); }
            100% { opacity: 0; transform: translateY(-10px) translate(-50%, -50%); }
        }

        .ripple {
            position: absolute;
            border-radius: 50%;
            border: 2px solid rgba(255, 255, 255, 0.6);
            pointer-events: none;
            z-index: 5;
            animation: ripple-animation 1.5s ease-out forwards;
        }

        @keyframes ripple-animation {
            from { width: 20px; height: 20px; opacity: 1; }
            to { width: 300px; height: 300px; opacity: 0; }
        }

        @media (max-width: 768px) {
            h1 { letter-spacing: 0.15em; }
            .subtitle { letter-spacing: 0.15em; margin-bottom: 3rem; }
            .countdown { gap: 1.2rem; }
        }
    </style>
</head>
<body>

    <canvas id="constellation"></canvas>

    <div class="content" id="mainContent">
        <h1>HALİT CENGİZ UZUNER</h1>
        <div class="subtitle" id="status">DİJİTAL İNŞA SÜRECİ BAŞLADI</div>
        
        <div class="countdown">
            <div class="time-unit">
                <div class="time-value" id="days">10</div>
                <div class="time-label">GÜN</div>
            </div>
            <div class="time-unit">
                <div class="time-value" id="hours">00</div>
                <div class="time-label">SAAT</div>
            </div>
            <div class="time-unit">
                <div class="time-value" id="minutes">00</div>
                <div class="time-label">DAKİKA</div>
            </div>
            <div class="time-unit">
                <div class="time-value" id="seconds">00</div>
                <div class="time-label">SANİYE</div>
            </div>
        </div>
    </div>

    <script>
        window.addEventListener('load', function() {
            // ============================================
            // 1. OLED BURN-IN KORUMA (PIXEL SHIFT)
            // ============================================
            const contentElement = document.getElementById('mainContent');
            
            function applyPixelShift() {
                // -3px ile +3px arası mikroskobik kaydırma
                const shiftX = (Math.random() - 0.5) * 6; 
                const shiftY = (Math.random() - 0.5) * 6;
                contentElement.style.transform = `translate(calc(-50% + ${shiftX}px), calc(-50% + ${shiftY}px))`;
            }

            // 45 saniyede bir tetikle
            setTimeout(() => {
                applyPixelShift();
                setInterval(applyPixelShift, 45000);
            }, 45000);

            // ============================================
            // 2. AFORİZMA KÜTÜPHANESİ
            // ============================================
            const aphorisms = [
                'İLAHİ ADALET, ZAMANIN ÖTESİNDE BİR HAKİKATTİR',
                'BİLGİ, DÜZENİN TEMEL TAŞIDIR',
                'MANTIK, KAOSUN ANTİDOTUDUR',
                'DÜŞÜNCE, EYLEMİN MİMARIDIR',
                'SİSTEM, ÖZGÜRLÜĞÜN KOŞULUDUR',
                'AKIL, KARANLIĞIN TEK IŞIĞIDIR',
                'LOJİK, GERÇEKLİĞİN DİLİDİR',
                'GERÇEK, AKIL YÜRÜTMENİN ÜRÜNÜDÜR',
                'TUTARLILIK, DOĞRUNUN İMZASIDIR',
                'SOYUTLAMA, BİLGELİĞİN YOLUDUR',
                'KAVRAM, DÜŞÜNCENİN BİRİMİDİR',
                'ZAMAN, NEDENSELLİĞİN GÖRÜNÜR BOYUTUDUR',
                'AN, SÜREKLİLİK YANILSAMASININ BİRİMİDİR',
                'İRADE, BELİRLENİMİN ÖZNEL ADLANMASIDIR',
                'KARAR, NEDENSELLİĞİN BİLİNÇTEKİ İZİDİR',
                'KAOS, DÜZENİN TESPİT EDİLMEMİŞ HALİDİR'
            ];

            function spawnAphorism(x, y) {
                // Ekranda çok fazla birikmesini önle
                if(document.querySelectorAll('.aphorism').length > 2) return;

                const aphorism = document.createElement('div');
                aphorism.className = 'aphorism';
                aphorism.textContent = aphorisms[Math.floor(Math.random() * aphorisms.length)];
                aphorism.style.left = x + 'px';
                aphorism.style.top = y + 'px';
                document.body.appendChild(aphorism);

                setTimeout(() => { aphorism.remove(); }, 2500);
            }

            function createRipple(x, y) {
                const ripple = document.createElement('div');
                ripple.className = 'ripple';
                ripple.style.left = (x - 10) + 'px';
                ripple.style.top = (y - 10) + 'px';
                document.body.appendChild(ripple);
                setTimeout(() => { ripple.remove(); }, 1500);
            }

            // ============================================
            // 3. DİNAMİK DURUM MESAJLARI
            // ============================================
            const statusMessages = [
                'DİJİTAL İNŞA SÜRECİ BAŞLADI',
                'YAPISAL VERİLER TASNİF EDİLİYOR',
                'BİLİŞSEL AĞLAR ÖRÜLÜYOR',
                'MANTIKSAL BAĞLANTILAR KURULUYOR',
                'GEÇMİŞ DOSYALAR İŞLENİYOR',
                'SİSTEM MİMARİSİ İNŞA EDİLİYOR',
                'ANLAMSAL KATMANLAR OLUŞTURULUYOR',
                'ENTELEKTÜEL ALTYAPI HAZIRLANIYOR'
            ];
            
            let currentStatusIndex = 0;
            const statusElement = document.getElementById('status');

            function cycleStatus() {
                statusElement.classList.add('fade');
                setTimeout(() => {
                    currentStatusIndex = (currentStatusIndex + 1) % statusMessages.length;
                    statusElement.textContent = statusMessages[currentStatusIndex];
                    statusElement.classList.remove('fade');
                }, 800);
            }
            setInterval(cycleStatus, 8000);

            // ============================================
            // 4. SAYAÇ MOTORU (BASİT VE SAĞLAM)
            // ============================================
            const targetDate = new Date();
            targetDate.setDate(targetDate.getDate() + 10);
            targetDate.setHours(0, 0, 0, 0);

            function updateCountdown() {
                const now = new Date().getTime();
                const distance = targetDate.getTime() - now;

                if (distance < 0) return;

                const days = Math.floor(distance / (1000 * 60 * 60 * 24));
                const hours = Math.floor((distance % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
                const minutes = Math.floor((distance % (1000 * 60 * 60)) / (1000 * 60));
                const seconds = Math.floor((distance % (1000 * 60)) / 1000);

                const fmt = (n) => String(n).padStart(2, '0');
                document.getElementById('days').textContent = fmt(days);
                document.getElementById('hours').textContent = fmt(hours);
                document.getElementById('minutes').textContent = fmt(minutes);
                document.getElementById('seconds').textContent = fmt(seconds);
            }
            updateCountdown();
            setInterval(updateCountdown, 1000);

            // ============================================
            // 5. GLITCH EFEKTİ (RASTGELE)
            // ============================================
            const canvasElement = document.getElementById('constellation');
            function triggerGlitch() {
                canvasElement.classList.add('glitch');
                setTimeout(() => { canvasElement.classList.remove('glitch'); }, 100);
                setTimeout(triggerGlitch, Math.random() * 30000 + 20000);
            }
            setTimeout(triggerGlitch, Math.random() * 30000 + 20000);

            // ============================================
            // 6. FİZİK & ANİMASYON MOTORU
            // ============================================
            const canvas = canvasElement;
            const ctx = canvas.getContext('2d');
            const dpr = window.devicePixelRatio || 1;

            let width = window.innerWidth;
            let height = window.innerHeight;
            let particles = [];
            let animationTime = 0;
            
            // Mouse/Touch
            let mouseX = null;
            let mouseY = null;

            // Donanım Tespiti (Tablet için)
            const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
            const repulsionRadius = isMobile ? 250 : 200;
            const repulsionForce = isMobile ? 1.5 : 1.0;

            // EVENT LISTENERS (Basitleştirilmiş)
            
            // Mouse
            document.addEventListener('mousemove', (e) => {
                mouseX = e.clientX;
                mouseY = e.clientY;
            });
            document.addEventListener('mouseleave', () => {
                mouseX = null;
                mouseY = null;
            });
            document.addEventListener('click', (e) => {
                createRipple(e.clientX, e.clientY);
                spawnAphorism(e.clientX, e.clientY);
            });

            // Touch (Tablet)
            document.addEventListener('touchstart', (e) => {
                e.preventDefault(); // Scroll engelle
                if (e.touches.length > 0) {
                    const touch = e.touches[0];
                    mouseX = touch.clientX;
                    mouseY = touch.clientY;
                    createRipple(touch.clientX, touch.clientY);
                    spawnAphorism(touch.clientX, touch.clientY);
                }
            }, { passive: false });

            document.addEventListener('touchmove', (e) => {
                e.preventDefault();
                if (e.touches.length > 0) {
                    mouseX = e.touches[0].clientX;
                    mouseY = e.touches[0].clientY;
                }
            }, { passive: false });

            document.addEventListener('touchend', () => {
                mouseX = null;
                mouseY = null;
            });

            function resizeCanvas() {
                width = window.innerWidth;
                height = window.innerHeight;
                canvas.width = width * dpr;
                canvas.height = height * dpr;
                canvas.style.width = width + 'px';
                canvas.style.height = height + 'px';
                ctx.scale(dpr, dpr);
                initParticles();
            }

            class Particle {
                constructor() {
                    this.baseX = Math.random() * width;
                    this.baseY = Math.random() * height;
                    this.x = this.baseX;
                    this.y = this.baseY;
                    
                    this.offsetX = Math.random() * 100;
                    this.offsetY = Math.random() * 100;
                    this.radiusX = Math.random() * 30 + 20;
                    this.radiusY = Math.random() * 30 + 20;
                    this.speedX = (Math.random() - 0.5) * 0.0015;
                    this.speedY = (Math.random() - 0.5) * 0.0015;
                    
                    this.baseSize = Math.random() * 1.5 + 1;
                    this.breathPhase = Math.random() * Math.PI * 2;
                    
                    this.vx = 0;
                    this.vy = 0;
                }

                update(time) {
                    // 1. Organik Salınım (Claude'un Orijinal İmzası)
                    let targetX = this.baseX + Math.sin(time * this.speedX + this.offsetX) * this.radiusX;
                    let targetY = this.baseY + Math.cos(time * this.speedY + this.offsetY) * this.radiusY;

                    // 2. Manyetik İtme (Repulsion)
                    if (mouseX !== null && mouseY !== null) {
                        const dx = this.x - mouseX;
                        const dy = this.y - mouseY;
                        const distance = Math.sqrt(dx * dx + dy * dy);

                        if (distance < repulsionRadius) {
                            const force = (1 - distance / repulsionRadius) * repulsionForce;
                            const angle = Math.atan2(dy, dx);
                            this.vx += Math.cos(angle) * force;
                            this.vy += Math.sin(angle) * force;
                        }
                    }

                    // Fizik Damping (Yumuşatma)
                    this.vx *= 0.92;
                    this.vy *= 0.92;

                    targetX += this.vx;
                    targetY += this.vy;

                    // Hedefe İnterpolasyon (Akıcılık)
                    this.x += (targetX - this.x) * 0.1;
                    this.y += (targetY - this.y) * 0.1;
                    
                    // Sınır koruma
                    if (this.baseX < -50) this.baseX = width + 50;
                    if (this.baseX > width + 50) this.baseX = -50;
                    if (this.baseY < -50) this.baseY = height + 50;
                    if (this.baseY > height + 50) this.baseY = -50;
                }

                draw(time) {
                    const breathSize = this.baseSize + Math.sin(time * 0.002 + this.breathPhase) * 0.3;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, Math.max(0.1, breathSize), 0, Math.PI * 2);
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
                    ctx.fill();
                }
            }

            function initParticles() {
                particles = [];
                // Mobil için sayıyı optimize et
                const count = width < 768 ? 50 : 100;
                for (let i = 0; i < count; i++) {
                    particles.push(new Particle());
                }
            }

            function drawConnections(time) {
                const maxDistance = width < 768 ? 120 : 180;
                const pulse = (Math.sin(time * 0.001) + 1) * 0.5;

                for (let i = 0; i < particles.length; i++) {
                    for (let j = i + 1; j < particles.length; j++) {
                        const dx = particles[i].x - particles[j].x;
                        const dy = particles[i].y - particles[j].y;
                        const distance = Math.sqrt(dx * dx + dy * dy);

                        if (distance < maxDistance) {
                            const opacity = (1 - distance / maxDistance) * 0.25;
                            const finalOpacity = opacity * (0.5 + pulse * 0.5);

                            ctx.beginPath();
                            ctx.moveTo(particles[i].x, particles[i].y);
                            ctx.lineTo(particles[j].x, particles[j].y);
                            ctx.strokeStyle = `rgba(255, 255, 255, ${finalOpacity})`;
                            ctx.lineWidth = 0.5;
                            ctx.stroke();
                        }
                    }
                }
            }

            function animate() {
                animationTime += 16;
                ctx.fillStyle = 'rgba(0, 0, 0, 0.03)'; // Ghosting
                ctx.fillRect(0, 0, width, height);

                particles.forEach(particle => {
                    particle.update(animationTime);
                    particle.draw(animationTime);
                });

                drawConnections(animationTime);
                requestAnimationFrame(animate);
            }

            window.addEventListener('resize', resizeCanvas);
            resizeCanvas();
            animate();
        });
    </script>
</body>
</html>
